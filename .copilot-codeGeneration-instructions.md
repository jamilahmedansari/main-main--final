# GitHub Copilot Code Generation Instructions

> **üìñ For complete feature list, all 77 routes, and comprehensive documentation:**
> **See `/workspace/AI_AGENTS_GUIDE.md`**
>
> This file contains detailed code generation patterns. For feature reference, see AI_AGENTS_GUIDE.md.

## 0. Context & Ground Rules

This repo already contains a **mostly complete implementation** of Talk-To-My-Lawyer:

- Next.js App Router (TypeScript, SSR, Server Actions)
- Supabase (Auth, PostgreSQL, RLS)
- Stripe (subscriptions + letter allowances)
- AI letter generation
- Free trial system
- Employee coupons + commission tracking
- Secure admin portal at `/secure-admin-gateway`

**CRITICAL: Do not rebuild the app or create new architecture.**

This is an **extension-only** project. See "WORKING WITH THIS CODEBASE" section (bottom of this document) for detailed guidance on what this means.

---

## Quick Reference

**When adding new code:**

- ‚úÖ Auth check: `import { createClient } from "@/lib/supabase/server"`
- ‚úÖ Admin routes: Under `/secure-admin-gateway/*` only
- ‚úÖ Database changes: New migration in `supabase/migrations/`
- ‚úÖ AI calls: Via Vercel AI SDK in Next.js API routes (OpenAI GPT-4)
- ‚úÖ Audit logging: `supabase.rpc('log_letter_audit', { ... })`
- ‚ùå Never: Call AI models outside of designated API routes
- ‚ùå Never: Expose OpenAI API key to client-side code
- ‚ùå Never: Routes under `/dashboard/admin` (legacy, blocked)
- ‚ùå Never: Multiple admin users (single admin only)

**Common patterns:**

```typescript
// Check letter allowance
const { data } = await supabase.rpc('check_letter_allowance', { u_id: userId })

// Admin authorization (correct)
WHERE role = 'admin'  // ‚úÖ Correct

// NOT this (is_super_user is a business flag, not admin role)
WHERE is_super_user = true  // ‚ùå Wrong for admin checks
```

---

## 1) Tech Stack (As Implemented)

### Core

- **Next.js** (App Router, `app/` directory ‚Äì see `package.json` for exact versions)
- **React + TypeScript**
- **Tailwind CSS + shadcn/ui** for UI components
- **Supabase**
  - Auth: email/password signups and logins
  - Database: PostgreSQL with migrations in `supabase/migrations/*.sql`
  - RLS policies and Postgres functions for business logic
- **Stripe**
  - Checkout sessions
  - Webhook/verification via `app/api/verify-payment/route.ts`

### AI Provider ‚Äì Current State

- **AI Model:** OpenAI GPT-4 Turbo via Vercel AI SDK
- **Implementation:** Direct integration in Next.js API routes
- **Files:**
  - `app/api/generate-letter/route.ts` - Letter generation
  - `app/api/letters/[id]/improve/route.ts` - Letter improvement

**Architecture:**

- AI generation happens in Next.js API routes (server-side only)
- Uses Vercel AI SDK (`@ai-sdk/openai` and `ai` packages)
- OpenAI API key stored securely in Next.js environment variables
- Type-safe, excellent DX, built-in streaming support
- Single deployment pipeline (all in Next.js)

---

## 2) Key Files & Folder Map

Copilot should assume this as the **source of truth**:

### App Routes

- Public & Auth:

  - `app/page.tsx` ‚Äì marketing/landing
  - `app/auth/login/page.tsx`
  - `app/auth/signup/page.tsx` (subscriber/employee flows)

- Subscriber / Employee:

  - `app/dashboard/page.tsx` ‚Äì role-based router for logged-in users
  - `app/dashboard/letters/page.tsx` ‚Äì subscriber "My Letters" list
  - `app/dashboard/letters/new/page.tsx` ‚Äì letter intake + submit form
  - `app/dashboard/letters/[id]/page.tsx` ‚Äì single letter detail for subscriber
  - `app/dashboard/subscription/page.tsx` ‚Äì subscription status & plans
  - `app/dashboard/commissions/page.tsx` ‚Äì **employee** commissions overview
  - `app/dashboard/coupons/page.tsx` ‚Äì **employee** coupon codes

- Legacy admin (do **not** extend):

  - `app/dashboard/admin/**` ‚Äì **legacy admin views**, now blocked by middleware

- Secure admin portal (primary admin surface ‚Äì **use this**):
  - `app/secure-admin-gateway/login/page.tsx` ‚Äì dual-auth login (email/password + portal key)
  - `app/secure-admin-gateway/dashboard/page.tsx` ‚Äì main admin dashboard (Review Queue, metrics)
  - `app/secure-admin-gateway/dashboard/letters/page.tsx` ‚Äì admin Review Center
  - `app/secure-admin-gateway/dashboard/all-letters/page.tsx` ‚Äì all letters
  - `app/secure-admin-gateway/dashboard/commissions/page.tsx` ‚Äì commission overview
  - `app/secure-admin-gateway/dashboard/analytics/page.tsx` ‚Äì analytics

### API Routes

- AI & letters:

  - `app/api/generate-letter/route.ts`
  - `app/api/letters/[id]/improve/route.ts`
  - `app/api/letters/[id]/approve/route.ts`
  - `app/api/letters/[id]/reject/route.ts`
  - `app/api/letters/[id]/start-review/route.ts`
  - `app/api/letters/[id]/submit/route.ts`
  - `app/api/letters/[id]/pdf/route.ts`
  - `app/api/letters/[id]/send-email/route.ts`
  - `app/api/letters/[id]/audit/route.ts`

- Auth / profile / admin:

  - `app/api/create-profile/route.ts`
  - `app/api/admin-auth/login/route.ts` ‚Äì admin login handler

- Stripe:
  - `app/api/create-checkout/route.ts`
  - `app/api/verify-payment/route.ts`

---

## Routes & Endpoints (Purpose + Role)

Keep this list consistent with the codebase. If adding or changing routes, update this section.

### UI Pages

**Public**

- `/` - marketing/landing; redirects signed-in users by role
- `/auth/login` - sign in
- `/auth/signup` - sign up
- `/auth/check-email` - post-email-sent screen
- `/auth/forgot-password` - request reset email
- `/auth/reset-password` - password reset page (Supabase reset session)

**Authenticated (role-based under /dashboard)**

- `/dashboard` - role router (subscriber/employee/admin)
- `/dashboard/letters` - subscriber letters list (employees redirected away)
- `/dashboard/letters/new` - subscriber letter intake
- `/dashboard/letters/[id]` - subscriber letter detail (admin may view)
- `/dashboard/subscription` - subscriber subscription/credits
- `/dashboard/settings` - intended subscriber settings
- `/dashboard/commissions` - employee commissions (admins may view)
- `/dashboard/coupons` - employee coupons (admins may view)
- `/dashboard/employee-settings` - intended employee settings
- `/dashboard/admin-settings` - intended admin settings

**Legacy/Alternate Admin UIs (do not extend)**

- `/dashboard/admin/*` - legacy admin pages (blocked/redirected by middleware)
- `/admin/*` - alternate admin UI (Supabase `profiles.role = 'admin'`)

**Secure Admin Portal (separate portal session, primary admin surface)**

- `/secure-admin-gateway/login` - portal login (email/password + portal key)
- `/secure-admin-gateway/dashboard` - portal dashboard
- `/secure-admin-gateway/review` - review center / queue
- `/secure-admin-gateway/review/[id]` - review a letter
- `/secure-admin-gateway/dashboard/letters` - review queue list (admin only)
- `/secure-admin-gateway/dashboard/analytics` - analytics (admin only)
- `/secure-admin-gateway/dashboard/commissions` - commissions (admin only)
- `/secure-admin-gateway/dashboard/all-letters` - all letters (admin only)

### API Endpoints

**Public / system-to-system**

- `GET /api/health` - health check
- `POST /api/auth/reset-password` - send reset email (rate-limited)
- `POST /api/stripe/webhook` - Stripe webhook (signature-verified; service-role DB)
- `POST /api/verify-payment` - verify Stripe session + create subscription (service-role DB)

**Authenticated (Supabase user session)**

- `POST /api/auth/update-password` - update password from reset session (rate-limited)
- `POST /api/create-checkout` - start checkout / coupon flows (intended subscriber)
- `GET /api/subscriptions/check-allowance` - credits check via `check_letter_allowance`
- `POST /api/subscriptions/activate` - add allowances + activate subscription

**Profile provisioning (sensitive)**

- `POST /api/create-profile` - create/update `profiles` record for the authenticated user only (uses service role)

**Letters (subscriber lifecycle)**

- `POST /api/generate-letter` - generate AI draft + create letter + move to `pending_review` (subscriber only)
- `POST /api/letters/[id]/submit` - submit letter for review (subscriber owner)
- `POST /api/letters/[id]/resubmit` - regenerate rejected letter + re-submit (subscriber owner)
- `POST /api/letters/[id]/send-email` - email approved/completed letter PDF (subscriber owner)
- `GET /api/letters/[id]/pdf` - download approved letter PDF (subscriber owner; admin)

**Admin / Review workflows**

- `POST /api/letters/improve` - AI improve helper (admin - Supabase role)
- `GET /api/letters/[id]/audit` - letter audit trail (currently admin/employee; ensure this never exposes letter content)
- `POST /api/letters/[id]/start-review` - set `under_review` (admin portal session)
- `POST /api/letters/[id]/approve` - approve + store final content (admin portal session)
- `POST /api/letters/[id]/reject` - reject with reason (admin portal session)
- `POST /api/letters/[id]/improve` - AI improve helper for review (admin portal session)
- `POST /api/letters/[id]/complete` - mark letter completed (admin portal session)

**Admin portal auth**

- `POST /api/admin-auth/login` - create admin portal session cookie
- `POST /api/admin-auth/logout` - destroy admin portal session cookie
- `GET /api/admin/analytics` - analytics (admin portal session)

**Admin or CRON**

- `POST /api/subscriptions/reset-monthly` - monthly reset (Bearer `CRON_SECRET` OR admin)

### Libraries

- Supabase:

  - `lib/supabase/server.ts` ‚Äì server-side client
  - `lib/supabase/client.ts` ‚Äì client-side client
  - `lib/supabase/middleware.ts` ‚Äì session + role-aware middleware

- Auth:

  - `lib/auth/get-user.ts` ‚Äì fetches Supabase session + profile
  - `lib/auth/admin-session.ts` ‚Äì **separate secure admin session** (cookie-based)

- Types:
  - `lib/database.types.ts` ‚Äì TS types for `Profile`, `Letter`, `Subscription`, `Commission`, etc.

### Components

- Core layout:

  - `components/dashboard-layout.tsx`

- Letters:

  - `components/review-letter-modal.tsx` ‚Äì admin review & AI improvement UI
  - `components/review-status-modal.tsx` ‚Äì subscriber review status timeline
  - `components/letter-actions.tsx` ‚Äì PDF / email actions

- Subscription / Stripe:

  - `components/subscription-card.tsx`
  - `components/subscription-modal.tsx`
  - `components/payment-verifier.tsx`

- UI:
  - `components/ui/*` ‚Äì shadcn components (Button, Card, Badge, Skeleton, etc.)

### Database & Migrations

- Primary schema & RLS:

  - `supabase/migrations/*.sql`
  - `COMPLETE_MIGRATION.sql` ‚Äì reference snapshot (do **not** re-run)

- Important tables:

  - `profiles` ‚Äì id, email, full_name, `role` (`subscriber` | `employee` | `admin`), `is_super_user`, etc.
  - `letters` ‚Äì letter lifecycle
  - `letter_audit_trail` ‚Äì review history
  - `subscriptions` ‚Äì plan, status, letters remaining
  - `employee_coupons`, `coupon_usage`
  - `commissions`
  - `security_audit_log`, `security_config`

- Important functions:
  - `check_letter_allowance(u_id)` ‚Äì decides if user can generate a letter (`has_allowance`, `remaining`, `plan_name`, `is_super`)
  - `log_letter_audit(...)` ‚Äì append audit entries
  - various RLS policies for `profiles`, `letters`, `coupon_usage`, etc.

---

## 3) Roles & Authorization

### Roles in `profiles.role`

- `'subscriber'`

  - Normal end-user
  - Access:
    - `/dashboard`
    - `/dashboard/letters`, `/dashboard/letters/new`, `/dashboard/letters/[id]`
    - `/dashboard/subscription`

- `'employee'`

  - Employee / affiliate
  - Access:
    - `/dashboard` ‚Üí redirected to `/dashboard/commissions`
    - `/dashboard/commissions`
    - `/dashboard/coupons`
  - **Cannot see any letters data** (no direct access to `letters`).

- `'admin'`
  - **Exactly one admin user in the entire system**
  - Created via script: `scripts/create-admin-user.ts`
  - Logs in via: `/secure-admin-gateway/login`
  - Access:
    - `/secure-admin-gateway/dashboard` and its child routes
    - Admin-only APIs (e.g. `/api/admin/super-user`)

### Single Admin Rule

- There is **one** admin row in `profiles` (the seeded admin).
- **Do not**:
  - Create UI to promote users to `role = 'admin'`.
  - Allow signup as admin.
  - Create "super admin" / "super user admin" tiers.

### Understanding `is_super_user` (IMPORTANT)

- `profiles.is_super_user` **is NOT an admin role**. It is a **business flag** used for:
  - Unlimited letter allowances (bypasses subscription checks in `check_letter_allowance`)
  - VIP/internal user privileges
  - Displayed in `app/dashboard/subscription/page.tsx` as "Super User Status"
  - **Does NOT grant admin portal access**
  - **Does NOT grant elevated permissions**

**Authorization Examples:**

```typescript
// ‚úÖ CORRECT: Check for admin authorization
const { data: profile } = await supabase
  .from("profiles")
  .select("role")
  .eq("id", userId)
  .single();

if (profile.role !== "admin") {
  return NextResponse.json({ error: "Unauthorized" }, { status: 403 });
}

// ‚ùå WRONG: Using is_super_user for authorization
if (!profile.is_super_user) {
  // Never do this for admin checks
  return NextResponse.json({ error: "Unauthorized" }, { status: 403 });
}

// ‚úÖ CORRECT: Using is_super_user for business logic
const allowance = await supabase.rpc("check_letter_allowance", {
  u_id: userId,
});
// Function internally checks is_super_user to grant unlimited letters
```

**Copilot must never treat `is_super_user` as an authorization role. All admin auth checks must use `role = 'admin'` only.**

---

## 4) Routing, Middleware & Sessions

### Middleware (`lib/supabase/middleware.ts` + `middleware.ts`)

- The root `middleware.ts` calls `updateSession(request)` from `lib/supabase/middleware.ts`.
- `updateSession` is responsible for:
  - Initializing Supabase SSR client.
  - Syncing auth cookies.
  - Fetching the user + role (from `profiles`).
  - Applying role-based routing and protection.

Key behaviors (Copilot must respect/extend):

1. **Admin Portal Protection**

   ```ts
   const adminPortalRoute =
     process.env.ADMIN_PORTAL_ROUTE || "secure-admin-gateway";

   if (pathname.startsWith(`/${adminPortalRoute}`)) {
     // `/secure-admin-gateway/login` is public
     // All other routes must have a valid admin session cookie
   }
   ```

   - Uses `verifyAdminSessionFromRequest(request)` from `lib/auth/admin-session.ts`.
   - If no valid admin session ‚Üí redirect to `/secure-admin-gateway/login`.

2. **Block Legacy Admin Routes**

   ```ts
   if (pathname.startsWith("/dashboard/admin")) {
     // Always redirect to /dashboard
   }
   ```

   - Do not add new code under `/dashboard/admin/**`.
     All admin work lives under `/secure-admin-gateway/*`.

3. **Dashboard Protection**

   - If `!user` and `pathname.startsWith('/dashboard')` ‚Üí redirect to `/auth/login`.
   - When at `/dashboard`, redirect based on `userRole`:
     - `admin` ‚Üí now effectively goes through admin portal flows
     - `employee` ‚Üí `/dashboard/commissions`
     - `subscriber` ‚Üí stays on `/dashboard`

### Admin Session (`lib/auth/admin-session.ts`)

- Separate from Supabase auth.
- Uses cookie `admin_session` with:

  - `userId`
  - `email`
  - `loginTime`
  - `lastActivity`

- Login flow:

  - `app/secure-admin-gateway/login/page.tsx` POSTs to:
    - `/api/admin-auth/login`
  - `/api/admin-auth/login`:
    - Validates **email/password + portal key**.
    - Uses `verifyAdminCredentials` and `createAdminSession`.
    - Credentials & portal key are from env variables.

- In admin-only pages under `/secure-admin-gateway/dashboard/**`:
  - Check with `isAdminAuthenticated()` and/or rely on middleware guard.

**When adding or changing admin-only pages, enforce both:**

1. Path is under `/secure-admin-gateway/...`
2. Protected by admin session (middleware) and `role = 'admin'` in Supabase.

---

## 5) Letter Lifecycle & Status Flow

Letter statuses are defined in the `letter_status` enum and in `lib/database.types.ts`:

```ts
export type LetterStatus =
  | "draft"
  | "generating"
  | "pending_review"
  | "under_review"
  | "approved"
  | "completed"
  | "rejected"
  | "failed";
```

**Canonical flow:**

```text
draft ‚Üí generating ‚Üí pending_review ‚Üí under_review ‚Üí approved/rejected ‚Üí completed/failed
```

Where:

- `draft`

  - User has started but not submitted letter for generation (may be implicit).

- `generating`

  - `/api/generate-letter` has created a record and is calling AI.

- `pending_review`

  - AI draft saved; waiting for admin review.

- `under_review`

  - Admin has opened the letter (see `start-review` API).

- `approved`

  - Admin approved final content.

- `rejected`

  - Admin rejected with a reason.

- `completed`

  - Fully processed: approved draft delivered (PDF/email).

- `failed`
  - AI generation or processing error.

**Audit Trail**

- Use `letter_audit_trail` and `log_letter_audit` Postgres function for:
  - status changes
  - approvals / rejections
  - failures

---

## 6) AI Integration ‚Äì OpenAI via Vercel AI SDK

### Current Implementation

The application uses **OpenAI GPT-4 Turbo** via the **Vercel AI SDK** for all AI-powered features.

**Key Files:**

1. `app/api/generate-letter/route.ts` - Letter generation
2. `app/api/letters/[id]/improve/route.ts` - Letter improvement

### Architecture Overview

```
Client ‚Üí Next.js API Route ‚Üí Vercel AI SDK ‚Üí OpenAI GPT-4 ‚Üí Response
```

**Benefits of this approach:**

- ‚úÖ Simple, single-codebase architecture
- ‚úÖ Type-safe end-to-end
- ‚úÖ Excellent developer experience with Vercel AI SDK
- ‚úÖ Built-in streaming support
- ‚úÖ Faster cold starts (no extra network hop)
- ‚úÖ Single deployment pipeline
- ‚úÖ Easier debugging and monitoring

### Standard AI Pattern

All AI calls should follow this pattern:

```typescript
import { openai } from "@ai-sdk/openai";
import { generateText } from "ai";

// In your API route
export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient();

    // 1. Auth check
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser();
    if (authError || !user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // 2. Validate API key is configured
    if (!process.env.OPENAI_API_KEY) {
      console.error("[AI] Missing OPENAI_API_KEY");
      return NextResponse.json(
        { error: "Server configuration error" },
        { status: 500 }
      );
    }

    // 3. Build your prompt
    const prompt = buildPrompt(/* your params */);

    // 4. Call OpenAI via Vercel AI SDK
    const { text: generatedContent } = await generateText({
      model: openai("gpt-4-turbo"),
      system:
        "You are a professional legal attorney drafting formal legal letters...",
      prompt,
      temperature: 0.7,
      maxTokens: 2048,
    });

    // 5. Validate response
    if (!generatedContent) {
      throw new Error("AI returned empty content");
    }

    // 6. Return result
    return NextResponse.json({ content: generatedContent });
  } catch (error: any) {
    console.error("[AI] Generation error:", error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}
```

### Letter Generation Pattern

Example from `app/api/generate-letter/route.ts`:

```typescript
import { openai } from "@ai-sdk/openai";
import { generateText } from "ai";

// Create letter record with 'generating' status
const { data: newLetter } = await supabase
  .from("letters")
  .insert({
    user_id: user.id,
    letter_type: letterType,
    status: "generating",
    intake_data: intakeData,
  })
  .select()
  .single();

try {
  // Generate letter using AI
  const { text: generatedContent } = await generateText({
    model: openai("gpt-4-turbo"),
    system:
      "You are a professional legal attorney drafting formal legal letters. Always produce professional, legally sound content with proper formatting.",
    prompt: buildPrompt(letterType, intakeData),
    temperature: 0.7,
    maxTokens: 2048,
  });

  // Update letter with generated content
  await supabase
    .from("letters")
    .update({
      ai_draft_content: generatedContent,
      status: "pending_review",
    })
    .eq("id", newLetter.id);

  // Log audit trail
  await supabase.rpc("log_letter_audit", {
    p_letter_id: newLetter.id,
    p_action: "created",
    p_old_status: "generating",
    p_new_status: "pending_review",
    p_notes: "Letter generated successfully by AI",
  });

  return NextResponse.json({
    success: true,
    letterId: newLetter.id,
    aiDraft: generatedContent,
  });
} catch (error) {
  // Mark as failed on error
  await supabase
    .from("letters")
    .update({ status: "failed" })
    .eq("id", newLetter.id);

  throw error;
}
```

### Letter Improvement Pattern

Example from `app/api/letters/[id]/improve/route.ts`:

```typescript
import { openai } from "@ai-sdk/openai";
import { generateText } from "ai";

// Verify admin authentication
const authError = await requireAdminAuth();
if (authError) return authError;

const { content, instruction } = await request.json();

// Build improvement prompt
const prompt = `
Current letter content:
${content}

Improvement instruction:
${instruction}

Please improve the letter according to the instruction while maintaining professional legal tone and formatting.
`;

// Call OpenAI for improvement
const { text: improvedContent } = await generateText({
  model: openai("gpt-4-turbo"),
  system:
    "You are a professional legal attorney improving formal legal letters. Always maintain professional legal tone and proper formatting.",
  prompt,
  temperature: 0.7,
  maxTokens: 2048,
});

return NextResponse.json({ improvedContent });
```

### Prompt Engineering Best Practices

1. **System Prompts**: Define the AI's role clearly

   ```typescript
   system: "You are a professional legal attorney drafting formal legal letters...";
   ```

2. **User Prompts**: Be specific with requirements

   ```typescript
   prompt: `Draft a ${letterType} letter with these requirements:
   - Professional legal tone
   - 300-500 words
   - Include proper formatting
   - Clear demands with deadlines`;
   ```

3. **Temperature**: Use 0.7 for balanced creativity and consistency

4. **Max Tokens**: Set to 2048 for letter content (adjust as needed)

### Error Handling

Always wrap AI calls in try-catch and handle failures gracefully:

```typescript
try {
  const { text } = await generateText({
    /* config */
  });

  if (!text) {
    throw new Error("AI returned empty content");
  }

  // Process success...
} catch (error: any) {
  console.error("[AI] Generation failed:", error);

  // Update database status to 'failed'
  await supabase
    .from("letters")
    .update({ status: "failed" })
    .eq("id", letterId);

  // Log audit trail
  await supabase.rpc("log_letter_audit", {
    p_letter_id: letterId,
    p_action: "generation_failed",
    p_notes: error.message,
  });

  return NextResponse.json({ error: "AI generation failed" }, { status: 500 });
}
```

### Rules

- ‚úÖ **DO** use Vercel AI SDK (`@ai-sdk/openai` and `ai` packages)
- ‚úÖ **DO** use `gpt-4-turbo` model for legal content
- ‚úÖ **DO** validate `OPENAI_API_KEY` is present before calling AI
- ‚úÖ **DO** handle AI errors gracefully with proper status updates
- ‚úÖ **DO** log all AI operations for debugging
- ‚ùå **DON'T** call OpenAI from client-side code
- ‚ùå **DON'T** expose `OPENAI_API_KEY` in client-accessible code
- ‚ùå **DON'T** use raw `fetch` to OpenAI - always use Vercel AI SDK
- ‚ùå **DON'T** skip error handling for AI calls

---

## 7) Subscriber Flow ‚Äì Letter Generation, Free Trial, Subscription

### New Letter Flow

Files:

- `app/dashboard/letters/new/page.tsx`
- `app/api/generate-letter/route.ts`
- `FREE_TRIAL_IMPLEMENTATION.md`

Behavior:

1. User fills out intake form:

   - Sender info
   - Recipient info
   - Issue description
   - Desired outcome
   - Letter type (`LETTER_TYPES` list)

2. On submit, client calls:

   ```ts
   const response = await fetch("/api/generate-letter", { ... })
   const { letterId, aiDraft, isFreeTrial } = await response.json()
   ```

3. After response:
   - Pushes to `/dashboard/letters/[id]?submitted=1`.
   - `ReviewStatusModal` handles the "Request received ‚Üí Under attorney review ‚Üí Posted to My Letters" timeline.

### Free Trial

- First letter is **free**:
  - `generate-letter` checks how many letters user has generated.
  - If zero ‚Üí allow without subscription, set `isFreeTrial = true`.
  - Subsequent letters:
    - Require active subscription with remaining credits.
    - If missing, return `{ needsSubscription: true }` and **HTTP 403/400**, and frontend pushes user to `/dashboard/subscription`.

### Subscription & Letter Allowances

Relevant files:

- `app/dashboard/subscription/page.tsx`
- `app/api/create-checkout/route.ts`
- `app/api/verify-payment/route.ts`
- Migrations:
  - `005_letter_allowance_system.sql`
  - `009_add_missing_subscription_fields.sql`
  - `010_add_missing_functions.sql`
- `DATABASE_FUNCTIONS.md`

Plans (as per business logic):

- One-time: 1 letter
- Monthly / yearly equivalents with 4 / 8 letters (see migrations and docs)

**Function `check_letter_allowance(u_id)`**:

- Returns `has_allowance`, `remaining`, `plan_name`, `is_super`.
- Used server-side to decide whether a subscriber can generate another letter.

**Key expectations for Copilot:**

- Do not change the meaning of `credits_remaining`, `remaining_letters`, or `plan_type`.
- When adding new server logic around letter creation, reuse `check_letter_allowance` instead of duplicating queries.
- Respect `is_super` / `is_super_user` as "unlimited access" for subscribers, **not** as an admin role.

---

## 8) Employee Coupons & Commissions

### Employee Coupon System

**Tables:**

- `employee_coupons` ‚Äì coupon codes owned by employees
- `coupon_usage` ‚Äì tracking who used which coupon
- `commissions` ‚Äì earnings from coupon usage

**Auto-Generation:**

- Trigger: When new employee profile created
- Format: `EMP-XXXXXX` (6 character hash)
- Discount: 20%
- Auto-active: `is_active = true`

**Commission Structure:**

- Commission rate: 5% of purchase amount
- Points: 1 point per coupon use
- Status: `pending` ‚Üí `paid`

**Employee Access:**

- Dashboard routes:
  - `/dashboard/coupons` ‚Äì view and manage their coupon codes
  - `/dashboard/commissions` ‚Äì view earnings and usage stats
- Cannot access letters data (RLS enforced)

**RLS Policies:**

- Employees can only see their own coupons
- Employees can only see commissions from their coupons
- Admin can see all coupons and commissions

---

## 9) TypeScript Best Practices

- Use strict TypeScript
- Define proper types for all data
- Use existing types from `lib/database.types.ts`
- Never use `any` without justification
- Prefer interfaces for object shapes
- Use type unions for status fields

**Example:**

```typescript
import { Database } from "@/lib/database.types";

type Profile = Database["public"]["Tables"]["profiles"]["Row"];
type LetterStatus = Database["public"]["Enums"]["letter_status"];
```

---

## 10) Component Patterns

- Use existing shadcn/ui components from `components/ui/`
- Follow existing component patterns in the codebase
- Keep components modular and reusable
- Use client components (`'use client'`) only when needed for interactivity
- Server components by default for better performance
- Properly type component props

**Example:**

```typescript
interface LetterCardProps {
  letter: Letter;
  onView?: (id: string) => void;
}

export function LetterCard({ letter, onView }: LetterCardProps) {
  // Implementation
}
```

---

## 11) API Route Conventions

- Use Next.js App Router conventions (`route.ts` files)
- Implement proper error handling
- Return consistent JSON responses
- **Always check authentication first**
- Validate input data
- Use appropriate HTTP status codes

**Standard Pattern:**

```typescript
import { createClient } from "@/lib/supabase/server";
import { NextResponse } from "next/server";

export async function POST(request: Request) {
  try {
    // 1. Auth check
    const supabase = await createClient();
    const {
      data: { user },
      error,
    } = await supabase.auth.getUser();
    if (error || !user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // 2. Parse and validate input
    const body = await request.json();
    // ... validation

    // 3. Business logic
    // ...

    // 4. Success response
    return NextResponse.json({ success: true, data: result });
  } catch (error) {
    console.error("API Error:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}
```

---

## 12) Security Best Practices

### Row Level Security (RLS)

- Always enable RLS on tables
- Use `auth.uid()` for user-specific policies
- Create separate policies for each operation (SELECT, INSERT, UPDATE, DELETE)
- Use helper function `get_user_role()` for role checks

**Example Policy:**

```sql
-- Subscribers can only see their own letters
CREATE POLICY "subscribers_view_own_letters"
ON letters FOR SELECT
TO authenticated
USING (
  user_id = auth.uid() AND
  get_user_role(auth.uid()) = 'subscriber'
);
```

### Environment Variables

Required in `.env.local`:

- `NEXT_PUBLIC_SUPABASE_URL`
- `NEXT_PUBLIC_SUPABASE_ANON_KEY`
- `SERVICE_ROLE_KEY`
- `OPENAI_API_KEY` (for Vercel AI SDK)
- `STRIPE_SECRET_KEY`
- `NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY`
- `ADMIN_EMAIL`
- `ADMIN_PASSWORD`
- `ADMIN_PORTAL_KEY`

### Audit Trail

Always log important actions to `letter_audit_trail`:

```typescript
await supabase.rpc("log_letter_audit", {
  p_letter_id: letterId,
  p_action: "approved",
  p_old_status: "pending_review",
  p_new_status: "approved",
  p_notes: "Letter approved by admin",
});
```

### Input Validation

- Validate all user input
- Sanitize data before database operations
- Use Zod or similar for schema validation
- Never trust client-side data

---

## 13) Development Environment

This is a GitHub Codespaces environment with:

- Node.js 18+
- pnpm package manager
- PostgreSQL client tools
- Supabase CLI
- Python 3 (for Jupyter notebooks)
- Go, LLDB debugger support

**Always respect the existing environment configuration and don't make assumptions about paths or tool availability.**

**Common Commands:**

```bash
# Install dependencies
pnpm install

# Run development server
pnpm dev

# Run Supabase locally
supabase start

# Create new migration
supabase migration new <name>

# Deploy Edge Functions
supabase functions deploy <function-name>
```

---

## 14) WORKING WITH THIS CODEBASE: EXTENSION, NOT RECONSTRUCTION

**The #1 rule: This is NOT a greenfield project.**

### What "Extension" Means

‚úÖ **DO THIS:**

- Add new API endpoints in existing `app/api/` structure
- Create new components in `components/` following existing patterns
- Add new pages under existing route groups (`/dashboard/*`, `/secure-admin-gateway/*`)
- Extend database schema with NEW migrations in `supabase/migrations/`
- Wire up incomplete features (e.g., missing API calls)
- Add validation and error handling to existing functions
- Migrate Gemini ‚Üí OpenAI in the two specified files

‚ùå **DO NOT DO THIS:**

- Create a new `/src` folder and move files there
- Redesign the routing from `/app` to something else
- Replace `components/ui/*` with a different UI library
- Drop and recreate existing database tables
- Rewrite working features "to make them better"
- Create `/app/admin` routes when `/secure-admin-gateway` exists
- Add new admin roles when the requirement is "single admin"

### When You See Incomplete Code

If you find:

- Missing error handling ‚Üí **Add it to the existing function**
- Hardcoded values ‚Üí **Extract to constants in existing files**
- TODO comments ‚Üí **Implement the TODO in place**
- Unused functions ‚Üí **Remove or wire them up**

Do NOT:

- Move the file to a "better" location
- Refactor the entire module
- Introduce new patterns that conflict with existing code

### Pattern Matching

Before writing new code:

1. **Search** for similar existing functionality
2. **Copy** the patterns you find (imports, error handling, typing)
3. **Extend** with your specific logic
4. **Stay consistent** with the rest of the file

Example: If every other API route uses `createClient()` from `@/lib/supabase/server`, your new route must too.

### File Organization

Existing structure you must respect:

```
app/
  api/              ‚Üê Server-side API routes
  auth/             ‚Üê Public auth pages
  dashboard/        ‚Üê Subscriber/employee areas
  secure-admin-gateway/  ‚Üê Admin-only area
components/         ‚Üê React components
  ui/               ‚Üê shadcn/ui primitives (DO NOT replace)
lib/
  auth/             ‚Üê Auth helpers
  supabase/         ‚Üê Supabase clients & middleware
  database.types.ts ‚Üê Generated types (DO NOT hand-edit)
supabase/migrations/ ‚Üê Database migrations (append only)
```

**If you need a new file, put it in the appropriate existing folder.**

### AI Integration Architecture

**Current Implementation:**

- ‚úÖ Using OpenAI GPT-4 Turbo via Vercel AI SDK
- ‚úÖ AI calls in Next.js API routes (server-side only)
- ‚úÖ Type-safe, excellent DX, production-ready

**Key Files:**

- `app/api/generate-letter/route.ts` - Letter generation with OpenAI
- `app/api/letters/[id]/improve/route.ts` - Letter improvement with OpenAI

**Pattern to Follow:**

```typescript
import { openai } from "@ai-sdk/openai";
import { generateText } from "ai";

const { text } = await generateText({
  model: openai("gpt-4-turbo"),
  system: "Your system prompt...",
  prompt: "Your user prompt...",
  temperature: 0.7,
  maxTokens: 2048,
});
```

**When adding new AI features:**

1. Use Vercel AI SDK (never raw fetch to OpenAI)
2. Always check `OPENAI_API_KEY` is configured
3. Use `gpt-4-turbo` model for legal content
4. Implement proper error handling
5. Log operations for debugging

### Code Quality Standards

- Match existing code style (indentation, naming, etc.)
- Add comments only where logic isn't self-evident
- Don't add docstrings to functions you didn't create
- Keep solutions simple and focused on the requirement
- Only add error handling for realistic failure scenarios
- Trust framework guarantees (Next.js, Supabase, etc.)

---

## Summary: Key Principles

1. **Extend, never reconstruct** ‚Äì Work within existing architecture
2. **Single admin only** ‚Äì Never create multiple admin users or roles
3. **`is_super_user` is business logic, not authorization** ‚Äì Use `role = 'admin'` for auth
4. **AI via Vercel AI SDK** ‚Äì Use `@ai-sdk/openai` in Next.js API routes only
5. **Pattern matching** ‚Äì Find similar code and follow its patterns
6. **RLS on everything** ‚Äì Enforce security at database level
7. **Audit trail** ‚Äì Log all important actions
8. **Validate input** ‚Äì Never trust client data
9. **Use GPT-4 Turbo** ‚Äì For all legal content generation
10. **Keep it simple** ‚Äì Don't over-engineer solutions
